	.EQU 	KBD_CNTL, $000
	.EQU 	KBD_STAT, $000
	.EQU 	KBD_DATA, $001
	.EQU 	KBD_FLUSH, $40
	.EQU 	TIM_CNTL, $030
	.EQU 	TIM_STAT, $030
	.EQU 	TIM_VALUE, $031
	.EQU 	TIM_COUNT, $034

	.EQU 	SCORE, $106	; $106-$1?? depending on how many digits
	.EQU 	LEVEL, $124	; $124-$125 supporting up to 99
	.EQU 	GROUND, $2EE	; Start of last row (where ground is)
	.EQU  CRT_VBUF, $100
	.EQU 	CRT_END, $313
	.EQU 	CRT_CNTL, $316
	.EQU 	CRT_ROWS, $0E	; Number of rows in CRT
	.EQU 	CRT_COLS, $26	; Number of columns per row
	.EQU	CRT_X, $314
	.EQU	CRT_Y, $315
	.EQU	CRT_DATA, $317
         	.EQU 	CLEAR_DISPLAY, $01
	.EQU 	BELL, $06

	.EQU 	INTERRUPT_ENA, $80
	.EQU 	RESET_READY_BIT, $40
	.EQU 	START_AFTER_LOAD, $10
	.EQU 	ENABLE_RESET_AND_START, $D0
	.EQU 	ENABLE_AND_RESET, $C0

	.EQU	PUT_NUM2, $E07

	; Game Related .EQUs
	.EQU	GROUND_CHAR, $2D	; ASCII for "-"
	.EQU	PROJ_CHAR, $A6	; ASCII for double vertical dash
	.EQU	BOMB_CHAR, $A4	; ASCII for currency sign
	.EQU	EXPLOSION1, $2A
	.EQU	EXPLOSION2, $B0
	; We may need multiple delays to have things move at different speeds
	; May need to test different delays to see how long in real time it takes
	; Delay at start of each level (maybe 2-5 seconds long, constant)
	; Delay for projectiles (constant)
	; Delay for bombs (constant)
	; Delay for enemy aircraft that changes based on time so need a word
	.EQU 	STARTLVL_DELAY, 8	; # of timer iters displaying level
	.EQU	BEATLVL_DELAY, 10	; # of timer iters displaying cleared msg
	.EQU	DROP_DELAY, 5
	.EQU 	BOMB_DELAY, 3	; # of timer iters before dropped bombs move
	.EQU 	SPAWN_DELAY, 5	; # of iters before enemy ships spawn
	.EQU	SPD1_DELAY, 3	; # of iters before ships move w/ different spds
	.EQU	SPD2_DELAY, 2
	; Speed 3 moves every clock cycle
	.EQU	MAX_BOMBS, 15

SETUP:	LDS# 	$E00
	; Keyboard setup
	LDA#	INTERRUPT_ENA
	OUTB	KBD_CNTL
	; Timer setup
	LDA	DELAY
	OUTW  TIM_VALUE
	LDA#	ENABLE_RESET_AND_START
	OUTB 	TIM_CNTL
	; Load initial stage
	; Probably just the ground, ship, score, level
	; Let the user have maybe 5 seconds before ships start spawning in
MAIN:	JSR	START_GAME
	JSR	START_LVL
DISPLAY_STRT:	INC	COUNTER
	LDA	COUNTER
	CMA#	1000
	JNE	DISPLAY_STRT
	PSH#	8
	PSH#	$CD
	JSR	CLR_DISPLAY
	ADS#	2
	SIE
RESET:	LDX#	0
WASTE_TIME:	NOP
	AOC#	300
	JLT	WASTE_TIME
	LDX#	0
LOOP:	LDA+	BOMBS
	CMA#	0
	JEQ	CONTINUE
	PSHX
	PSH#	BOMBS
	JSR	MOVE_BOMB
	ADS#	2
CONTINUE:	AOC#	MAX_BOMBS
	JLT	LOOP
	JMP	RESET
	; Decreasing delay will make enemy ships, proj, and player move smoother
	; but make bombs fall slower (because more interrupts)
DELAY:	.WORD 2000	; Game base speed
	; Stores the ports for ^ and the left | of the ship/AA gun
SHIP_R1:	.WORD $100 + (11 * CRT_COLS) + (CRT_COLS/2) - 1
SHIP_R2:	.WORD $100 + (12*CRT_COLS) + (CRT_COLS/2) - 2
PROJECTILES:	.BLKW	10, 0
SHIP_HEALTH:	.WORD 100	; Change to a smaller num for IG
CURR_LEVEL:	.WORD	1
CURR_SCORE:	.WORD	0
NAVY_SIZE:	.WORD	7	; Each level has 7 * level enemies
NUM_ENEMIES:	.WORD	0
ENEMY_SHIPS:	.BLKW	7, 0
ENEMY_SPDS:	.BLKW	7, 0
BOMBS:	.BLKW MAX_BOMBS, 0

	; Subroutines
	.EQU	@, $100

	; Initializes graphics and starts game
START_GAME:	BGN#  0
	PSHA
	PSHX
	; Print Score
	LDX#	0
PRINT_SCORE:	LDC	SCORE_STR	; Print "Score:"
	OUTB+	CRT_VBUF
	AOC#	6
	JNE	PRINT_SCORE
	JSR	PUT_SCORE
	; Print level
	LDX#  0
PRINT_LEVEL:	LDC	LEVEL_STR	; Print "Level:"
	; To not overwrite Score, shift over XR (leave room for the level #)
	ADX#	30
	OUTB+	CRT_VBUF
	; Return back to original XR so next character can be gotten
	SBX#	30
	AOC#	6
	JNE	PRINT_LEVEL	; Print numbers for level
	JSR	PUT_LEVEL
	; Build the Turret
	JSR 	DISPLAY_SHIP
	; Print the ground
	LDA#  GROUND_CHAR	; Load up ground character
	LDX#  GROUND	; Set ground to start on last row
PRINT_GROUND:	OUTB+	0	; Output across whole row
	AOC# 	CRT_END
	JLE   PRINT_GROUND
	POPA
	POPX
	FIN#  0
	RTN
SCORE_STR:	.WORD	'Sco'
	.WORD	're:'
LEVEL_STR:	.WORD	'Lev'	; Can shorten to lvl if need space for score
	.WORD	'el:'

	; Display on Screen the start of level
START_LVL:	BGN# 	0
	PSHA
	PSHX
	LDX#	0
PRINT_SLVL:	LDC	LVL_S_STR
	OUTB&	SL_PORT
	AOC#	6
	JLT	PRINT_SLVL
	LDA#	22
	OUTB	CRT_X
	LDA#	6
	OUTB	CRT_Y
	LDA	CURR_LEVEL
	JSR	PUT_NUM2
	LDA#	39
	OUTB	CRT_X
	POPX
	POPA
	FIN# 	0
	RTN
LVL_S_STR:	.WORD	'Lev'
	.WORD	'el '
SL_PORT:	.WORD	$1CD

	; Display on Screen the beating level
BEAT_LVL:	BGN# 	0
	PSHA
	PSHX
	LDX#	0
PRINT_BLVL:	LDC	LVL_B_STR
	OUTB&	BL_PORT
	AOC#	15
	JLT	PRINT_BLVL
	POPX
	POPA
	FIN# 	0
	RTN
LVL_B_STR:	.WORD	'Lev'
	.WORD	'el '
	.WORD	'Com'
	.WORD	'ple'
	.WORD	'te!'
BL_PORT:	.WORD	$1C9

	; Displays 'Game Over' and halts
GAME_OVER:	BGN#	0
	CIE
	LDA#	CLEAR_DISPLAY
	OUTB	CRT_CNTL
	LDX#	0
GO_PRINT:	LDC	GO_STR
	OUTB&	GO_PORT
	AOC#	9
	JLT	GO_PRINT
	HLT
	FIN#	0
	RTN
GO_STR:	.WORD	'Gam'
	.WORD	'e O'
	.WORD	'ver'
GO_PORT:	.WORD	$1CD

	; Clear start/beat level from screen
	.EQU	SIZE_WORDS, 3
	.EQU	START_INDEX, 2
CLR_DISPLAY:	BGN# 	0
	PSHA
	PSHX
	LDX#	0
CLR_DISP:	LDA#	' '
	ADX	!START_INDEX
	OUTB+	CRT_VBUF
	SBX	!START_INDEX
	AOC	!SIZE_WORDS
	JNE	CLR_DISP
	POPX
	POPA
	FIN# 	0
	RTN

	; Display Score
PUT_SCORE:	BGN# 	0
	PSHA
	PSHX
	LDA#	7
	OUTB	CRT_X
	LDA#	1
	OUTB	CRT_Y
	LDA	CURR_SCORE
	JSR	PUT_NUM2
	LDA#	39
	OUTB	CRT_X
	POPX
	POPA
	FIN# 	0
	RTN

	; Display Level
PUT_LEVEL:	BGN# 	0
	PSHA
	PSHX
	LDA#	37
	OUTB	CRT_X
	LDA#	1
	OUTB	CRT_Y
	LDA	CURR_LEVEL
	JSR	PUT_NUM2
	LDA#	39
	OUTB	CRT_X
	POPX
	POPA
	FIN# 	0
	RTN

	; Add to the Score
	.EQU	SPEED_ARRAY, 3
	.EQU	ENEMY_INDEX, 2
ADD_SCORE:	BGN#	0
	PSHA
	PSHX
	; Use index from enemy to look at corresponding speed
	LDX	!ENEMY_INDEX
	LDA&	!SPEED_ARRAY
	CMA#	3
	JLT 	ADD_MAG1
	CMA#	5
	JLT	ADD_MAG2
	CMA#  7
	JLT	ADD_MAG3
ADD_MAG1:	LDA	CURR_SCORE
	ADA#	3
	STA	CURR_SCORE
	JMP	FINISH_SCORE
ADD_MAG2:	LDA	CURR_SCORE
	ADA#	5
	STA	CURR_SCORE
	JMP	FINISH_SCORE
ADD_MAG3:	LDA	CURR_SCORE
	ADA#	7
	STA	CURR_SCORE
	JMP	FINISH_SCORE
FINISH_SCORE:	POPX
	POPA
	FIN#	0
	RTN

	; Check if level is complete
LEVEL_DONE:	BGN#	0
	PSHA
	PSHX
	LDA	NAVY_SIZE
	CMA#	0
	JNE	EXIT_LVL_DNE
	CIE		; Finish displaying stuff
	; Display beat level
	JSR	BEAT_LVL
	LDX#	0
BEAT_DISPLAY:	AOC#	3000
	JLT	BEAT_DISPLAY
	PSH#	16
	PSH#	$C9
	JSR	CLR_DISPLAY
	ADS#	2
	LDA#	0
	STA	COUNTER
	INC	CURR_LEVEL
	LDA#	7	; Get new enemy total
	MUL	CURR_LEVEL
	STA	NAVY_SIZE
	JSR	PUT_LEVEL
	; Display start level
PRINTED_LVL:	JSR	START_LVL
	LDX#	0
STRT_DISPLAY:	AOC#	3000
	JLT	STRT_DISPLAY
	PSH#	8
	PSH#	$CD
	JSR	CLR_DISPLAY
	ADS#	2
	SIE
EXIT_LVL_DNE:	POPX
	POPA
	FIN#	0
	RTN
COUNTER:	.WORD	0

	; Displays ship at ports
	; Uses global ship variables
DISPLAY_SHIP:	BGN#	0
	PSHA
	PSHX
	; Check for collision with bomb before each character display to
	; avoid ACC reloading
	PSH#	1
	PSH	SHIP_R1
	JSR	BOMB_PLAYER
	ADS#	1	; Reuse 1 on stack
	LDA#  '^'
	OUTB*	SHIP_R1
	LDX# 	1
	LDA	SHIP_R2
	ADA#	1
	PSHA
	JSR	BOMB_PLAYER
	ADS#	1	; Reuse 1 on stack
	LDA#	'-'
	OUTB& SHIP_R2
	LDA#	'|'
	OUTB*	SHIP_R2
	ADX#	1
	OUTB&	SHIP_R2
	; Check ship's left and right here to avoid needing to reload ACC
	PSH	SHIP_R2
	JSR	BOMB_PLAYER
	ADS#	1	; Reuse 1 on stack
	LDA	SHIP_R2
	ADA#	2
	PSHA
	JSR	BOMB_PLAYER
	ADS#	2
	POPX
	POPA
	FIN# 	0
	RTN

	; Clears ship
	.EQU	C_ROW1, 3
	.EQU 	C_ROW2, 2
CLEAR_SHIP:	BGN#	0
	PSHA
	PSHX
	LDX#	0
	LDA# 	' '	; Clear previous ship positions
	OUTB*	!C_ROW1
CLEAR_R2:	OUTB&	!C_ROW2
	AOC#	3
	JLT	CLEAR_R2
	POPX
	POPA
	FIN#	0
	RTN

	; Moves the ship left(1) or right(2)
	.EQU	LorR, 4
	.EQU	M_ROW1, 3
	.EQU	M_ROW2, 2
	.EQU	LEFTMOST_POS, $2C8
	.EQU	RIGHTMOST_POS, $2ED
MOVE_SHIP:	BGN# 	0
	PSHA
	PSHX
	PSH*	!M_ROW1	; Preemptively push current addresses for clear
	PSH*	!M_ROW2
	LDA	!LorR
	CMA#	1
	JNE	M_RIGHT
	LDA*	!M_ROW2
	CMA#	LEFTMOST_POS	; Check if already at leftmost position
	JEQ	MOVE_DONE
	DEC*	!M_ROW1	; Set new ship ports
	DEC*	!M_ROW2
	JMP	M_MOVE
M_RIGHT:	LDA*	!M_ROW2
	ADA#	2
	CMA#	RIGHTMOST_POS	; Check if already at rightmost position
	JEQ	MOVE_DONE
	INC*	!M_ROW1	; Set new ship ports
	INC*	!M_ROW2
M_MOVE:	JSR	CLEAR_SHIP	; Clear ship
	JSR 	DISPLAY_SHIP	; Display ship at new ports
MOVE_DONE:	ADS#	2	; Remove parameters for clear from stack
	POPX
	POPA
	FIN#	0
	RTN

	; Check for empty slot in bomb array and circular loop logic
	.EQU	BOMBS_END, BOMBS + MAX_BOMBS - 1
	.EQU	NE_BOMBS, 3
	.EQU	NE_PORT, 2
NEXT_EMPTY:	BGN#	0
	PSHA
	PSHX
	LDX#	0
NEXT_CHECK:	LDA&	!NE_BOMBS
	CMA#	0
	JEQ	NEXT_STORE
	AOC#	MAX_BOMBS
	JLT	NEXT_CHECK
NEXT_STORE:	LDA	!NE_PORT
	STA&	!NE_BOMBS
	POPX
	POPA
	FIN#	0
	RTN
CURR_ADDR:	.WORD 0

	; Drops bomb from random ship's middle port
	.EQU	DB_ENEMIES, 3
	.EQU	DB_BOMBS, 2
DROP_BOMBS:	BGN#	0
	PSHA
	PSHX
	PSH#	5	; Get random index
	JSR	RANDOM
	ADS#	1
	TAX
	LDA&	!DB_ENEMIES
	CMA#	0
	JEQ	DB_DONE
	STA	DB_PORT
	TXA
	ADA#	1
	MUL#	38	; Check that middle port is displayed
	STA	DB_END
	ADA#	$100	; Check GEQ leftmost port in row
	SBA	DB_PORT
	JGT	DB_DONE
	LDA	DB_END	; Check LEQ rightmost port in row
	ADA#	$125
	SBA	DB_PORT
	CMA#	2
	JLT	DB_DONE
	LDA&	!DB_ENEMIES	; Get middle port
	ADA#	1
	PSH	!DB_BOMBS	; Find empty slot in BOMBS
	PSHA
	JSR	NEXT_EMPTY
	ADS#	2
DB_DONE:	POPX
	POPA
	FIN#	0
	RTN
DB_PORT:	.WORD	0
DB_END:	.WORD	0

	; Moves one bomb down
	.EQU	MB_INDEX, 3
	.EQU	MB_BOMBS, 2
MOVE_BOMB:	BGN#	0
	PSHA
	PSHX
	LDA&	!MB_BOMBS
	STA	MB_PORT	; Clear bomb
	INB*	MB_PORT
	CMA#	BOMB_CHAR
	JNE	MB_NO_CLR	; Do not clear non-bomb chars
	LDA#	' '
	OUTB*	MB_PORT
MB_NO_CLR:	LDA	MB_PORT
	ADA#	38
	STA	MB_PORT
	; Compare to check row and then collision
	CMA#	$2A2
	JLT	MB_STORE
	CMA#	$2ED
	JGT	MB_CLEAR
	PSH#	0
	PSH	MB_PORT
	JSR	BOMB_PLAYER
	ADS#	2
	CMA#	1
	JEQ	MB_CLEAR
MB_STORE:	LDA	MB_PORT
	STA&	!MB_BOMBS
	INB*	MB_PORT
	CMA#	' '
	JNE	MB_DONE	; Do not display over other chars
	LDA#	BOMB_CHAR
	OUTB*	MB_PORT
	JMP	MB_DONE
MB_CLEAR:	CLR&	!MB_BOMBS
MB_DONE:	POPX
	POPA
	FIN#	0
	RTN
MB_PORT:	.WORD	0

	; Bomb-player collision subroutine
	; Checks for a bomb-player collision and decrements health
	; Also checks if player has ran out of health
	; Returns whether a collision occured
	.EQU	BP_MOVING, 3	; 0 for checking ship chars, 1 for bomb chars
	.EQU	BP_PORT, 2
BOMB_PLAYER:	BGN#	0
	LDA	!BP_MOVING
	CMA#	0
	JNE	BP_CHECK_BOMB
	INB*	!BP_PORT
	CMA#	'^'
	JEQ	BP_HIT
	CMA#	'|'
	JEQ	BP_HIT
	CMA#	'-'
	JNE	BP_NO_HIT
BP_CHECK_BOMB:	INB*	!BP_PORT
	CMA#	BOMB_CHAR
	JNE	BP_NO_HIT
BP_HIT:	DEC	SHIP_HEALTH
	LDA	SHIP_HEALTH
	CMA#	0
	JGT	BP_NOT_OVER
	JSR	GAME_OVER
BP_NOT_OVER:	LDA#	1
	JMP	BP_DONE
BP_NO_HIT:	LDA#	0
BP_DONE:	FIN#	0
	RTN

	; Clears all bombs from screen and array
	.EQU	CB_BOMBS, 2
CLR_ALL_BOMB:	BGN#	0
	PSHA
	PSHX
	LDX#	0
CAB_LOOP:	LDA&	!CB_BOMBS
	STA	CAB_PORT
	CLR&	!CB_BOMBS
	LDA#	' '
	OUTB*	CAB_PORT
	AOC#	MAX_BOMBS
	JLT	CAB_LOOP
	POPX
	POPA
	FIN#	0
	RTN
CAB_PORT:	.WORD	0

	; Shoot subroutine shoots if no projectile in row above ship
	.EQU	S_PROJ, 3
	.EQU	S_SHIP_R1, 2
SHOOT:	BGN# 	0
	PSHA
	PSHX
	LDX#	9
CHECK_PROJ:	LDA&	!S_PROJ
	CMA#	0	; See if there is space for projectile
	JEQ	ADD_PROJ	; If space not filled, add projectile
	; Check if port is in row above ship
CHECK_ABOVE:	CMA#	$100 + (10 * CRT_COLS)
	JGE	DONE	; No space for new projectile
SUB_JUMP:	SOJ	CHECK_PROJ	; Port is in row above ship, check next element
	; Open space above ship
ADD_PROJ:	LDA	!S_SHIP_R1
	SBA#	38
	STA&	!S_PROJ
	; Small hack to get the projectile to display right above the ship
	; since move moves before displaying
	STA	S_PORT
	LDA#	PROJ_CHAR
	OUTB*	S_PORT
DONE:	POPX
	POPA
	FIN# 	0
	RTN
S_PORT:	.WORD	0

	; Get new position for each projectile
	.EQU	MP_PROJ, 4
	.EQU	MP_ENEMIES, 3
	.EQU	MP_SPEEDS, 2
MOVE_PROJ:	BGN# 	0
	PSHA
	PSHX
	PSH	!MP_PROJ
	JSR	CLEAR_PROJ	; Clear current projectiles
	ADS#	1
	LDX#	0
MOVING:	LDA&	!MP_PROJ	; Shift projectiles up a row
	STA	CLR_PORT	; For clearing if there is a collision
	SBA#	38
	STA	PROJ_PORT
	CMA#	$126	; See if it is above second row
	JLT	MP_RESET
	; Check if projectile hits an enemy ship
	INB*	PROJ_PORT
	CMA#	'|'
	JEQ	CLEAR_PE	; There is a hit
	CMA#	'o'
	JNE	SAVE_PROJ	; No hit, continue moving projectiles
CLEAR_PE:	LDA	PROJ_PORT	; Calculate index in enemies and speeds
	SBA#	$FF
	DIV#	38
	SBA#	1
	PSH	CLR_PORT
	PSH	!MP_PROJ
	PSHA
	PSH	!MP_ENEMIES
	PSH	!MP_SPEEDS
	JSR	PROJ_ENEMY
	ADS#	5
	JMP	CHECK_INDEX
	; Not out of screen & did not hit enemy ship, save new location
SAVE_PROJ:	LDA	PROJ_PORT
	STA&	!MP_PROJ
	JMP	CHECK_INDEX
MP_RESET:	CLR&	!MP_PROJ	; If proj goes out of screen, clear in array
CHECK_INDEX:	AOC#	10
	JLT	MOVING
	PSH	!MP_PROJ
	JSR	DISPLAY_PROJ	; Redisplay projectiles at new ports
	ADS#	1
	POPX
	POPA
	FIN#	0
	RTN
PROJ_PORT:	.WORD	0
CLR_PORT:	.WORD	0

	; Display projectiles
	.EQU	D_PROJ, 2
DISPLAY_PROJ:	BGN#	0
	PSHA
	PSHX
	LDX#	0
DP_LOOP:	LDA&	!D_PROJ
	STA	D_CURR_PORT
	LDA#  PROJ_CHAR
	OUTB*	D_CURR_PORT
	AOC#	10
	JLT	DP_LOOP
	POPX
	POPA
	FIN# 	0
	RTN
D_CURR_PORT:	.WORD	0

	; Clear projectiles from screen, not array
	.EQU	C_PROJ, 2
CLEAR_PROJ:	BGN#	0
	PSHA
	PSHX
	LDX#	0
CP_LOOP:	LDA&	!C_PROJ
	STA	C_CURR_PORT
	LDA#	' '
	OUTB*	C_CURR_PORT
	AOC#	10
	JLT	CP_LOOP
	POPX
	POPA
	FIN# 	0
	RTN
C_CURR_PORT:	.WORD	0

	; Projectile enemy collision handling
	.EQU	PE_PORT, 6
	.EQU	PE_PROJECTILES, 5
	.EQU	PE_INDEX, 4
	.EQU	PE_ENEMIES, 3
	.EQU	PE_SPEEDS, 2
PROJ_ENEMY:	BGN#	0
	PSHA
	PSHX
	PSH	!PE_SPEEDS	; Add to the score
	PSH	!PE_INDEX
	JSR	ADD_SCORE
	ADS#	2
	JSR	PUT_SCORE
	PSH	!PE_ENEMIES
	PSH	!PE_SPEEDS
	PSH	!PE_INDEX
	JSR	CLEAR_ENEMY
	ADS#	3
	LDX	!PE_INDEX
	CLR&	!PE_ENEMIES
	CLR&	!PE_SPEEDS
	DEC	NUM_ENEMIES
	LDX#	0
PE_LOOP:	LDA&	!PE_PROJECTILES	; Look for where port exists in array
	CMA	!PE_PORT
	JNE	PE_CHECK
	CLR&	!PE_PROJECTILES
	JMP	PE_DONE
PE_CHECK:	AOC	!10
	JLT	PE_LOOP
PE_DONE:	DEC	NAVY_SIZE
	JSR	LEVEL_DONE
	POPX
	POPA
	FIN# 	0
	RTN

	; Move enemy ships
	.EQU	M_MV_SPEEDS, 5	; 2 bits to represent each speed
	.EQU	M_ENEMIES, 4
	.EQU	M_SPEEDS, 3
	.EQU	M_PROJECTILES, 2
MOVE_ENEMIES:	BGN# 	0
	PSHA
	PSHX
	LDX#	0
CLR_ENEMIES:	LDA&	!M_SPEEDS	; Map speeds to bit
	CMA#	0
	JEQ	M_CONTINUE	; All bits off, no movement
	CMA#	3
	JLT	M_SPD1
	CMA#	5
	JLT	M_SPD2
	LDA	!M_MV_SPEEDS	; Check if bit is set for speed 3
	JMP	ME_MOVE
M_SPD1:	LDA	!M_MV_SPEEDS	; Check if bit is set for speed 1
	AND#	2
	JLE	M_CONTINUE
	JMP	ME_MOVE
M_SPD2:	LDA	!M_MV_SPEEDS	; Check if bit is set for speed 2
	AND#	1
	JLE	M_CONTINUE
ME_MOVE:	PSH	!M_ENEMIES
	PSH	!M_SPEEDS
	PSHX
	JSR	CLEAR_ENEMY	; Clear current enemy
	ADS#	3
	LDA&	!M_SPEEDS	; Get direction (left is odd right is even)
	MOD#	2
	JEQ	MOVE_RIGHT
	DEC&	!M_ENEMIES	; Shift enemy to the left
	LDA&	!M_ENEMIES
	STA	ME_CURR_PORT
	INB*	ME_CURR_PORT	; Check if moving into a projectile
	CMA#	PROJ_CHAR
	JNE	ME_CHK_LEFT
	PSH	ME_CURR_PORT
	PSH	!M_PROJECTILES
	PSHX
	PSH	!M_ENEMIES
	PSH	!M_SPEEDS
	JSR	PROJ_ENEMY
	ADS#	5
	;PSH#	!M_MV_SPEEDS	; Add to the score
	;PSHX
	;JSR	ADD_SCORE
	;ADS#	2
	JMP	M_CONTINUE
ME_CHK_LEFT:	TXA		; Is right port of enemy past left side of CRT?
	ADA#	1
	MUL#	38
	ADA#	$FD
	CMA&	!M_ENEMIES
	JEQ	RESET_ENEMY
	JMP	ME_DISPLAY
MOVE_RIGHT:	INC&	!M_ENEMIES	; Shift enemy to the right
	LDA&	!M_ENEMIES
	ADA#	2
	STA	ME_CURR_PORT
	INB*	ME_CURR_PORT	; Check if moving into a projectile
	CMA#	PROJ_CHAR
	JNE	ME_CHK_RIGHT
	PSH	ME_CURR_PORT
	PSH	!M_PROJECTILES
	PSHX
	PSH	!M_ENEMIES
	PSH	!M_SPEEDS
	JSR	PROJ_ENEMY
	ADS#	5
	;PSH#	!M_MV_SPEEDS	; Add to the score
	;PSHX
	;JSR	ADD_SCORE
	;ADS#	2
	JMP	M_CONTINUE
ME_CHK_RIGHT:	TXA		; Is left port of enemy past right side of CRT?
	ADA#	1
	MUL#	38
	ADA#	$126
	CMA&	!M_ENEMIES
	JNE	ME_DISPLAY
RESET_ENEMY:	LDA#	' '
	OUTB*	ME_CURR_PORT
	CLR&	!M_ENEMIES	; Delete enemy object
	CLR&	!M_SPEEDS
	DEC	NUM_ENEMIES
	JMP	M_CONTINUE
ME_DISPLAY:	PSH&	!M_ENEMIES
	PSHX
	JSR	DISPLAY_ENEMY	; Redisplay ships at new ports
	ADS#	2
M_CONTINUE:	AOC#	7
	JLT 	CLR_ENEMIES
	POPX
	POPA
	FIN#	0
	RTN
ME_CURR_PORT:	.WORD	0

	; Display enemy ship
	.EQU	DE_PORT, 3
	.EQU	DE_ROW, 2
DISPLAY_ENEMY:	BGN#	0
	PSHA
	PSHX
	INC	!DE_ROW	; XR is off by 1 since 0 based
	LDA	!DE_ROW	; Get starting index
	MUL#	38
	STA	DE_END
	ADA#	$100
	SBA	!DE_PORT
	JLE	DE_START_0
	TAX
	JMP	DE_GET_END
DE_START_0:	LDX#	0
DE_GET_END:	LDA	DE_END	; Get ending index
	ADA#	$125
	SBA	!DE_PORT
	CMA#	2
	JGE	DE_END_2
	JMP	DE_STORE_END
DE_END_2:	LDA#	2
DE_STORE_END:	STA	DE_END
	; Display enemy
DE_OUT_LOOP:	TXA
	MOD#	2
	JNE	DE_MIDDLE
	LDA#	'|'
	JMP	DE_OUT
DE_MIDDLE:	LDA#	'o'
DE_OUT:	OUTB&	!DE_PORT
	AOC	DE_END
	JLE	DE_OUT_LOOP
DE_DONE:	POPX
	POPA
	FIN# 	0
	RTN
DE_END:	.WORD	0

	; Clear enemy ship from screen
	.EQU	C_ENEMIES, 4
	.EQU	C_SPEEDS, 3
	.EQU	C_INDEX, 2
CLEAR_ENEMY:	BGN#	0
	PSHA
	PSHX
	LDX	!C_INDEX
	LDA&	!C_ENEMIES
	STA	CE_PORT
	TXA		; Get starting index
	ADA#	1
	MUL#	38
	STA	CE_END
	ADA#	$100
	SBA	CE_PORT
	JLE	CE_START_0
	TAX
	JMP	CE_GET_END
CE_START_0:	LDX#	0
CE_GET_END:	LDA	CE_END	; Get ending index
	ADA#	$125
	SBA	CE_PORT
	CMA#	2
	JGE	CE_END_2
	JMP	CE_STORE_END
CE_END_2:	LDA#	2
CE_STORE_END:	STA	CE_END
	LDA# 	' '	; Clear previous enemy ship position
CLEAR_ALL:	OUTB&	CE_PORT
	AOC	CE_END
	JLE	CLEAR_ALL
EXIT_CLEAR:	POPX
	POPA
	FIN# 	0
	RTN
CE_PORT:	.WORD	0
CE_END:	.WORD	0

	; Spawns an enemy ship
	.EQU 	SPEED, 4	; CBV
	.EQU	ENEMY_ARR, 3	; CBA
	.EQU	SPEED_ARR, 2	; CBA
SPAWN:	BGN#	0
	PSHA
	PSHX
	PSH#	5	; Get number between 0-5 inclusive
	JSR	RANDOM	; This represents the row it goes on
	ADS#	1
	TAX
CHECK_OPEN:	LDA&	!ENEMY_ARR	; Check if no enemy on row
	CMA#	0
	JEQ	ROW_GOOD	; XR will store the index to store at
	AOC#	7
	JLT	CHECK_OPEN
	LDX#	0	; Reset to start of array if checking last element
	JMP	CHECK_OPEN
ROW_GOOD:	TXA		; Get offset
	ADA#	1
	MUL# 	38
	STA	S_ROW
	LDA	!SPEED	; Check direction
	MOD#	2
	JEQ	S_RIGHT
	LDA#	$125	; Port = $125 + ACC * 38 if from right
	JMP 	S_CONT
S_RIGHT:	LDA#	$FE	; Port = $FE + ACC * 38 if from left
S_CONT:	ADA	S_ROW
	STA&	!ENEMY_ARR
	LDA	!SPEED
	STA&	!SPEED_ARR
	POPX
	POPA
	FIN#	0
	RTN
S_ROW:	.WORD	0

	; Random function from pong
	; Gets a number between 0 and RANDOM_MAX
	.EQU	RANDOM_MAX, 2
RANDOM:	BGN#	0
	LDA 	SEED
	MUL#	2179
	ADA#	1892
	MOD#	295
	STA	SEED
	INC	!RANDOM_MAX
	MOD	!RANDOM_MAX
	FIN#	0
	RTN
SEED:	.WORD 0

	; ISRs
	.EQU	@, $500

	; Keyboard ISR for player controls
	.EQU	LEFT, 1
	.EQU 	RIGHT, 2
KBD_ISR:	PSHA
	LDA#	0	; Finish this interrupt before allowing more
	OUTB	KBD_CNTL
	INB	KBD_DATA
	CMA#	$1B
	JEQ 	MOVEMENT	; Control sequence must be a ship move
	CMA# 	$20
	JNE 	KBD_DONE
	PSH#	PROJECTILES
	PSH	SHIP_R1
	JSR	SHOOT
	ADS#	2
MOVEMENT:	INB 	KBD_DATA
	CMA#	$4B
	JNE 	CHECK_RIGHT
	PSH# 	LEFT
	JMP  	MOVE
CHECK_RIGHT:	CMA# 	$4D
	JNE 	KBD_DONE
	PSH# 	RIGHT
MOVE:	PSH#	SHIP_R1
	PSH#	SHIP_R2
	JSR 	MOVE_SHIP
	ADS# 	3
KBD_DONE:	LDA#	INTERRUPT_ENA	; Re-enable KBD interrupts
	OUTB	KBD_CNTL
	POPA
	IRTN

	; Timer ISR
TIMER_ISR: 	PSHA
	PSHX
	PSH#	PROJECTILES
	PSH#	ENEMY_SHIPS
	PSH#	ENEMY_SPDS
	JSR 	MOVE_PROJ	; Move projectile(s)
	ADS# 	3
	LDX# 	0
	INC	TIMERS
	LDA	TIMERS
	CMA#	SPAWN_DELAY
	JLT	DROP_ACTION
	LDA	NUM_ENEMIES
	CMA#	7	; See if there is room for new enemies
	JGE	DROP_ACTION
	CMA	NAVY_SIZE
	JGE	DROP_ACTION
	CLR+	TIMERS
	PSH#	5	; Get speed (between 1 and 6)
	JSR	RANDOM
	ADS#	1
	ADA#	1
	PSHA
	PSH#	ENEMY_SHIPS
	PSH#	ENEMY_SPDS
	JSR	SPAWN
	ADS#	3
	INC	NUM_ENEMIES
DROP_ACTION:	ADX#	1	; Drop bombs
	INC+	TIMERS
	LDA+	TIMERS
	CMA#	DROP_DELAY
	JLT	T_SPEED1
	CLR+	TIMERS
	LDA	NUM_ENEMIES
	CMA#	0
	JEQ	T_SPEED1
	PSH#	ENEMY_SHIPS
	PSH#	BOMBS
	JSR	DROP_BOMBS
	ADS#	2
	; Add to speeds a certain number to make it like CHMOD
	; One call of move based on the speed value passed
T_SPEED1:	ADX#	1	; Speeds 1 and 2
	INC+	TIMERS
	LDA+	TIMERS
	CMA#	SPD1_DELAY
	JLT	T_SPEED2
	CLR+	TIMERS
	INC	MV_SPEEDS
T_SPEED2:	ADX#	1	; Speeds 3 and 4
	INC+	TIMERS
	LDA+	TIMERS
	CMA#	SPD2_DELAY
	JLT	ENEMY_ACTION
	CLR+	TIMERS
	LDA	MV_SPEEDS
	ADA#	2
ENEMY_ACTION:	CMA#	0	; Moves enemies based on MV_SPEEDS
	JEQ	TIMER_DONE
	PSHA
	PSH#	ENEMY_SHIPS
	PSH#	ENEMY_SPDS
	PSH#	PROJECTILES
	JSR	MOVE_ENEMIES
	ADS#	4
TIMER_DONE:	CLR	MV_SPEEDS
	LDA#	ENABLE_AND_RESET
         	OUTB	TIM_CNTL
	POPX
         	POPA
         	IRTN		; END OF TIMER_ISR
MV_SPEEDS:	.WORD	0
	; Timers in order of spawn, dropping, speeds (2)
TIMERS:	.BLKW	4, 0

	; Interrupt Vector
	.EQU @, $FF8
	.WORD KBD_ISR
	.EQU @, $FFB
	.WORD	TIMER_ISR
