	.EQU 	KBD_CNTL, $000
	.EQU 	KBD_STAT, $000
	.EQU 	KBD_DATA, $001
	.EQU 	KBD_FLUSH, $40
	.EQU 	TIM_CNTL, $030
	.EQU 	TIM_STAT, $030
	.EQU 	TIM_VALUE, $031
	.EQU 	TIM_COUNT, $034

	.EQU 	SCORE, $106	; $106-$1?? depending on how many digits
	.EQU 	LEVEL, $124	; $124-$125 supporting up to 99
	.EQU 	GROUND, $2EE	; Start of last row (where ground is)
	.EQU  CRT_VBUF, $100
	.EQU 	CRT_END, $313
	.EQU 	CRT_CNTL, $316
	.EQU 	CRT_ROWS, $0E	; Number of rows in CRT
	.EQU 	CRT_COLS, $26	; Number of columns per row
          	.EQU 	CLEAR_DISPLAY, $01
	.EQU 	BELL, $06

	.EQU 	INTERRUPT_ENA, $80
	.EQU 	RESET_READY_BIT, $40
	.EQU 	START_AFTER_LOAD, $10
	.EQU 	ENABLE_RESET_AND_START, $D0
	.EQU 	ENABLE_AND_RESET, $C0

	; Game Related .EQUs
	.EQU	GROUND_CHAR, $2D	; ASCII for "-"
	.EQU	PLAY_DELAY, 1 ; # of timer iterations before projectile moves
	.EQU	WINNER_DELAY, 10; # of timer iterations while winner shown

SETUP:	LDS# 	$E00
	; Keyboard setup
	LDA#	INTERRUPT_ENA
	OUTB	KBD_CNTL
	; Timer setup
	LDA	DELAY
	OUTW  TIM_VALUE
	LDA#	TIMERISR
	STA 	$FFB		
	LDA#	ENABLE_RESET_AND_START
	OUTB 	TIM_CNTL  
	SIE
	; Load initial stage
	; Probably just the ground, ship, score, level
	; Let the user have maybe 5 seconds before ships start spawning in
MAIN:	JSR START_GAME
LOOP:	NOP
	JMP	LOOP
	HLT

DELAY:	.WORD	$200
; Stores the ports for ^ and the left | of the ship/AA gun
SHIP_R1:	.WORD $100 + (11 * CRT_COLS) + (CRT_COLS/2) - 1
SHIP_R2:	.WORD $100 + (12*CRT_COLS) + (CRT_COLS/2) - 2

	; Subroutines
	.EQU	@, $200

	; void startGame()
	; Loads graphics
	; Need to go through first row and load score and level
	; Score: ######	Lvl: ##
	; Ground can be ------ or _____ see what looks better

START_GAME:	BGN#  0
	PSHA
	PSHX 
	; Print Score
	LDX#	0
PRINT_SCORE:	LDC	SCORE_STR
	OUTB+	CRT_VBUF
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_SCORE
	LDA# '0'
SCORE_PT2:	OUTB+ CRT_VBUF
	AOC# 16
	JLT SCORE_PT2
	; Print level
	LDX#  0	
PRINT_LEVEL:	LDC	LEVEL_STR
	; To not overwrite Score, shift over XR (leave room for the level #)
	ADX#	30
	OUTB+	CRT_VBUF
	; Return back to original XR so next character can be gotten
	SBX#	30
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_LEVEL
PRINT_PT2:	LDA# '0'
	OUTB	LEVEL
	LDA# '1'
	OUTB	LEVEL + 1
	; Build the Turret
	JSR 	DISPLAY_SHIP		
	; Print the ground
	LDA#  GROUND_CHAR	; Load up ground character
	LDX#  GROUND	; Set ground to start on last row
PRINT_GROUND:	OUTB+	0	; Output across whole row
	AOC# 	CRT_END
	JLE   PRINT_GROUND
	POPA
	POPX
	FIN#  0
	RTN          
SCORE_STR:	.WORD	'Sco'
SCORE_STR2:	.WORD	're:'
LEVEL_STR:	.WORD	'Lev'	; Can shorten to lvl if need space for score
LEVEL_STR2:	.WORD	'el:'

	; Work in progress
	; Need to figure out how to initialize and move projectiles
SHOOT:	BGN# 	0
	PSHA
	POPA
	FIN# 	0
	RTN

	; Displays ship at ports
	; Uses global ship variables
DISPLAY_SHIP:	BGN#	0
	PSHA
	PSHX
	LDA#  '^'
	OUTB*	SHIP_R1
	LDX# 	1
	LDA#	'-'
	OUTB& SHIP_R2
	LDA#	'|'	
	OUTB*	SHIP_R2
	ADX#	1		
	OUTB&	SHIP_R2
	POPX
	POPA
	FIN# 	0
	RTN

	; Clears ship
	.EQU	C_ROW1, 3
	.EQU 	C_ROW2, 2
CLEAR_SHIP:	BGN#	0
	PSHA
	PSHX
	LDX#	0
	LDA# 	' '	; Clear previous ship positions
	OUTB*	!C_ROW1
CLEAR_R2:	OUTB&	!C_ROW2
	AOC#	3
	JLT	CLEAR_R2
	POPX
	POPA
	FIN#	0
	RTN

	; Moves the ship left(1) or right(2)
	.EQU	LorR, 4
	.EQU	M_ROW1, 3
	.EQU	M_ROW2, 2
	.EQU	LEFTMOST_POS, $2C8
	.EQU	RIGHTMOST_POS, $2ED
MOVE_SHIP:	BGN# 	0
	PSHA
	PSHX
	PSH*	!M_ROW1	; Preemptively push current addresses for clear
	PSH*	!M_ROW2
	LDA	!LorR
	CMA#	1
	JNE	M_RIGHT
	LDA*	!M_ROW2
	CMA#	LEFTMOST_POS	; Check if already at leftmost position
	JEQ	MOVE_DONE
	DEC*	!M_ROW1	; Set new ship ports
	DEC*	!M_ROW2
	JMP	M_MOVE
M_RIGHT:	LDA*	!M_ROW2
	ADA#	2
	CMA#	RIGHTMOST_POS	; Check if already at rightmost position
	JEQ	MOVE_DONE
	INC*	!M_ROW1	; Set new ship ports
	INC*	!M_ROW2
M_MOVE:	JSR	CLEAR_SHIP	; Clear ship
	JSR 	DISPLAY_SHIP	; Display ship at new ports
MOVE_DONE:	ADS#	2	; Remove parameters for clear from stack
	POPX
	POPA
	FIN#	0
	RTN

	; Random function from pong
	.EQU	RANDOMMAX, 2
RANDOM:	BGN#	0
	LDA 	SEED
	MUL#	2779
	ADA#	1997
	MOD#	2048
	STA	SEED
	INC	!RANDOMMAX
	MOD	!RANDOMMAX
	FIN#	0
	RTN
SEED:	.WORD 0

; void play()

; For timer and moving everything, we have to plan how things move
; and how to decide what direction something moves in
; Timer altered from pong code
TIMERISR: 	PSHA
          	INC   TIMER
          	LDA	TIMER
	CMA	TIMER_CNT
	JLT	TIMER_DONE
	CMA#	WINNER_DELAY
	JNE	TIMER1
	LDA#	PLAY_DELAY	; set timer play since just announced winner
	STA	TIMER_CNT		
	JSR	START_GAME	
	JMP	TIMER3	; game just started now
TIMER1:	JSR	PLAY	
TIMER3:	LDA#	0
	CLR	TIMER	; reset timer count
TIMER_DONE:	LDA#	ENABLE_AND_RESET
          	OUTB	TIM_CNTL
          	POPA
          	IRTN		; END OF TIMERISR
TIMER:	.WORD	0
TIMER_CNT:	.WORD	PLAY_DELAY

	; ISRs
	.EQU	@, $300
	; Keyboard ISR for player controls
	.EQU	LEFT, 1
	.EQU 	RIGHT, 2
KBD_ISR:	PSHA
	LDA#	0	; Finish this interrupt before allowing more
	OUTB	KBD_CNTL
	INB	KBD_DATA
	CMA#	$1B
	JEQ 	MOVEMENT
	CMA# 	$20
	JNE 	KBD_DONE
	JSR	SHOOT
MOVEMENT:	INB 	KBD_DATA
	CMA#	$4B
	JNE 	CHECK_RIGHT
	PSH# 	LEFT
	JMP  	MOVE
CHECK_RIGHT:	CMA# 	$4D
	JNE 	KBD_DONE
	PSH# 	RIGHT
MOVE:	PSH#	SHIP_R1
	PSH#	SHIP_R2
	JSR 	MOVE_SHIP
	ADS# 	3
KBD_DONE:	LDA#	INTERRUPT_ENA	; Re-enable KBD interrupts
	OUTB	KBD_CNTL
	POPA
	IRTN

	.EQU @, $FF8
	.WORD KBD_ISR

; /\
;|--|

; ^
;|-|