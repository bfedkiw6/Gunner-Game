	.EQU 	KBD_CNTL, $000
	.EQU 	KBD_STAT, $000
	.EQU 	KBD_DATA, $001
	.EQU 	KBD_FLUSH, $40
	.EQU 	TIM_CNTL, $030
	.EQU 	TIM_STAT, $030
	.EQU 	TIM_VALUE, $031
	.EQU 	TIM_COUNT, $034

	.EQU 	SCORE, $106	; $106-$1?? depending on how many digits
	.EQU 	LEVEL, $124	; $124-$125 supporting up to 99
	.EQU 	GROUND, $2EE	; Start of last row (where ground is)
	.EQU  CRT_VBUF, $100
	.EQU 	CRT_END, $313
	.EQU 	CRT_CNTL, $316
	.EQU 	CRT_ROWS, $0E	; Number of rows in CRT
	.EQU 	CRT_COLS, $26	; Number of columns per row
          	.EQU 	CLEAR_DISPLAY, $01
	.EQU 	BELL, $06

	.EQU 	INTERRUPT_ENA, $80
	.EQU 	RESET_READY_BIT, $40
	.EQU 	START_AFTER_LOAD, $10
	.EQU 	ENABLE_RESET_AND_START, $D0
	.EQU 	ENABLE_AND_RESET, $C0

	; Game Related .EQUs
	.EQU	GROUND_CHAR, $2D	; ASCII for "-"
	.EQU	PROJ_CHAR, $A6
	; We may need multiple delays to have things move at different speeds
	; May need to test different delays to see how long in real time it takes
	; Delay at start of each level (maybe 2-5 seconds long, constant)
	; Delay for projectiles (constant)
	; Delay for bombs (constant)
	; Delay for enemy aircraft that changes based on time so need a word
	.EQU 	STARTLVL_DELAY, 8	; # of timer iters displaying level
	.EQU	BEATLVL_DELAY, 10	; # of timer iters displaying cleared msg
	.EQU	PROJ_DELAY, 1 	; # of timer iters before projectiles move
	.EQU 	BOMB_DELAY, 5	; # of timer iters before dropped bombs move


SETUP:	LDS# 	$E00
	; Keyboard setup
	LDA#	INTERRUPT_ENA
	OUTB	KBD_CNTL
	; Timer setup
	LDA	DELAY
	OUTW  TIM_VALUE		
	LDA#	ENABLE_RESET_AND_START
	OUTB 	TIM_CNTL  
	SIE
	; Load initial stage
	; Probably just the ground, ship, score, level
	; Let the user have maybe 5 seconds before ships start spawning in
MAIN:	JSR	START_GAME
	ADS#	1	
LOOP:	NOP
	JMP	LOOP
	HLT
; Stores the ports for ^ and the left | of the ship/AA gun
SHIP_R1:	.WORD $100 + (11 * CRT_COLS) + (CRT_COLS/2) - 1
SHIP_R2:	.WORD $100 + (12*CRT_COLS) + (CRT_COLS/2) - 2
PROJECTILES:	.BLKW	10, 0
SHIP_HEALTH:	.WORD 5
SPEED1:	.BLKW	12, 0
SPEED2:	.BLKW	12, 0
SPEED3:	.BLKW	12, 0
SPEED4:	.BLKW	12, 0
SPEED5:	.BLKW	12, 0

	; Subroutines
	.EQU	@, $200

	; Initializes graphics and starts game
START_GAME:	BGN#  0
	PSHA
	PSHX 
	; Print Score
	LDX#	0
PRINT_SCORE:	LDC	SCORE_STR
	OUTB+	CRT_VBUF
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_SCORE
	LDA# '0'
SCORE_PT2:	OUTB+ CRT_VBUF
	AOC# 16
	JLT SCORE_PT2
	; Print level
	LDX#  0	
PRINT_LEVEL:	LDC	LEVEL_STR
	; To not overwrite Score, shift over XR (leave room for the level #)
	ADX#	30
	OUTB+	CRT_VBUF
	; Return back to original XR so next character can be gotten
	SBX#	30
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_LEVEL
PRINT_PT2:	LDA# '0'
	OUTB	LEVEL
	LDA# '1'
	OUTB	LEVEL + 1
	; Build the Turret
	JSR 	DISPLAY_SHIP		
	; Print the ground
	LDA#  GROUND_CHAR	; Load up ground character
	LDX#  GROUND	; Set ground to start on last row
PRINT_GROUND:	OUTB+	0	; Output across whole row
	AOC# 	CRT_END
	JLE   PRINT_GROUND
	POPA
	POPX
	FIN#  0
	RTN          
SCORE_STR:	.WORD	'Sco'
SCORE_STR2:	.WORD	're:'
LEVEL_STR:	.WORD	'Lev'	; Can shorten to lvl if need space for score
LEVEL_STR2:	.WORD	'el:'

	; Shoot subroutine shoots if no projectile in row above ship
	.EQU	S_PROJ, 3
	.EQU	S_SHIP_R1, 2
SHOOT:	BGN# 	0
	PSHA
	PSHX
	LDX#	9
CHECK_PROJ:	LDA&	!S_PROJ
	CMA#	0	; See if there is space for projectile
	JEQ	ADD_PROJ	; If space not filled, add projectile
	; Check if port is in row above ship
CHECK_ABOVE:	CMA#	$100 + (10 * CRT_COLS)
	JGE	DONE	; No space for new projectile	
SUB_JUMP:	SOJ	CHECK_PROJ	; Port is in row above ship, check next element
	; Open space above ship	
ADD_PROJ:	LDA	!S_SHIP_R1
	SBA#	38
	STA&	!S_PROJ
	; Small hack to get the projectile to display right above the ship
	; since move moves before displaying
	STA	S_PORT
	LDA#	PROJ_CHAR
	OUTB*	S_PORT
DONE:	POPX
	POPA
	FIN# 	0
	RTN
S_PORT:	.WORD	0

	; Get new position for each projectile
	.EQU	M_PROJ, 2
MOVE_PROJ:	BGN# 	0
	PSHA
	PSHX
	PSH	!M_PROJ	
	JSR	CLEAR_PROJ	; Clear current projectiles
	ADS#	1
	LDX#	0
MOVING:	LDA&	!M_PROJ	; Shift projectiles up a row
	SBA#	38
	CMA#	$126	; See if it is out playing field
	JLT	RESET		
	STA&	!M_PROJ	; Not out of screen, save new loation
	JMP	CHECK_INDEX	
RESET:	CLR&	!M_PROJ	; If proj goes out of screen, clear in array
CHECK_INDEX:	AOC#	10
	JLT	MOVING
	PSH	!M_PROJ
	JSR	DISPLAY_PROJ	; Redisplay projectiles at new ports
	ADS#	1
	POPX	
	POPA
	FIN#	0 	
	RTN

	; Display projectiles
	.EQU	D_PROJ, 2
DISPLAY_PROJ:	BGN#	0
	PSHA	
	PSHX
	LDX#	0
DP_LOOP:	LDA&	!D_PROJ
	STA	D_CURR_PORT
	LDA#  PROJ_CHAR
	OUTB*	D_CURR_PORT
	AOC#	10
	JLT	DP_LOOP
	POPX
	POPA
	FIN# 	0
	RTN
D_CURR_PORT:	.WORD	0

	; Clear projectiles from screen, not array
	.EQU	C_PROJ, 2
CLEAR_PROJ:	BGN#	0
	PSHA
	PSHX
	LDX#	0
CP_LOOP:	LDA&	!C_PROJ
	STA	C_CURR_PORT
	LDA#	' '
	OUTB*	C_CURR_PORT
	AOC#	10
	JLT	CP_LOOP
	POPX
	POPA
	FIN# 	0
	RTN
C_CURR_PORT:	.WORD	0

	; Display enemy ship
	.EQU	D_ENMY_PORT, 2
DISPLAY_ENMY:	BGN#	0
	PSHA	
	PSHX
	LDX# 	1
	LDA#	'o'
	OUTB& !D_ENMY_PORT
	LDA#	'|'	
	OUTB*	!D_ENMY_PORT
	ADX#	1		
	OUTB&	!D_ENMY_PORT
	POPX
	POPA
	FIN# 	0
	RTN

	; Clear enemy ship from screen (also possibly from array)
	.EQU	C_ENEMY, 4
	.EQU	INDEX, 3
	.EQU	HIT, 2
CLEAR_ENMY:	BGN#	0
	PSHA
	PSHX
	LDX	!INDEX
	LDA&	!C_ENEMY
	STA	C_ENMY_PORT
	LDX#	0
	LDA# 	' '	; Clear previous enemy ship positions
CLEAR_ALL:	OUTB&	C_ENMY_PORT
	AOC#	3
	JLT	CLEAR_ALL
	LDA	!HIT	; See if ship was hit and needs to be cleared from array
	CMA#	1
	JNE	EXIT_CLEAR
	LDX	!INDEX
	LDA#	0
	STA&	!C_ENEMY
EXIT_CLEAR:	POPX
	POPA
	FIN# 	0
	RTN
C_ENMY_PORT:	.WORD	0

	; Displays ship at ports
	; Uses global ship variables
DISPLAY_SHIP:	BGN#	0
	PSHA
	PSHX
	LDA#  '^'
	OUTB*	SHIP_R1
	LDX# 	1
	LDA#	'-'
	OUTB& SHIP_R2
	LDA#	'|'	
	OUTB*	SHIP_R2
	ADX#	1		
	OUTB&	SHIP_R2
	POPX
	POPA
	FIN# 	0
	RTN

	; Clears ship
	.EQU	C_ROW1, 3
	.EQU 	C_ROW2, 2
CLEAR_SHIP:	BGN#	0
	PSHA
	PSHX
	LDX#	0
	LDA# 	' '	; Clear previous ship positions
	OUTB*	!C_ROW1
CLEAR_R2:	OUTB&	!C_ROW2
	AOC#	3
	JLT	CLEAR_R2
	POPX
	POPA
	FIN#	0
	RTN

	; Moves the ship left(1) or right(2)
	.EQU	LorR, 4
	.EQU	M_ROW1, 3
	.EQU	M_ROW2, 2
	.EQU	LEFTMOST_POS, $2C8
	.EQU	RIGHTMOST_POS, $2ED
MOVE_SHIP:	BGN# 	0
	PSHA
	PSHX
	PSH*	!M_ROW1	; Preemptively push current addresses for clear
	PSH*	!M_ROW2
	LDA	!LorR
	CMA#	1
	JNE	M_RIGHT
	LDA*	!M_ROW2
	CMA#	LEFTMOST_POS	; Check if already at leftmost position
	JEQ	MOVE_DONE
	DEC*	!M_ROW1	; Set new ship ports
	DEC*	!M_ROW2
	JMP	M_MOVE
M_RIGHT:	LDA*	!M_ROW2
	ADA#	2
	CMA#	RIGHTMOST_POS	; Check if already at rightmost position
	JEQ	MOVE_DONE
	INC*	!M_ROW1	; Set new ship ports
	INC*	!M_ROW2
M_MOVE:	JSR	CLEAR_SHIP	; Clear ship
	JSR 	DISPLAY_SHIP	; Display ship at new ports
MOVE_DONE:	ADS#	2	; Remove parameters for clear from stack
	POPX
	POPA
	FIN#	0
	RTN

	; Random function from pong
	.EQU	RANDOM_MAX, 2
RANDOM:	BGN#	0
	LDA 	SEED
	MUL#	2779
	ADA#	1997
	MOD#	2048
	STA	SEED
	INC	!RANDOM_MAX
	MOD	!RANDOM_MAX
	FIN#	0
	RTN
SEED:	.WORD 0

	; ISRs
	.EQU	@, $400

	; Keyboard ISR for player controls
	.EQU	LEFT, 1
	.EQU 	RIGHT, 2
KBD_ISR:	PSHA
	LDA#	0	; Finish this interrupt before allowing more
	OUTB	KBD_CNTL
	INB	KBD_DATA
	CMA#	$1B
	JEQ 	MOVEMENT	; Control sequence must be a ship move
	CMA# 	$20
	JNE 	KBD_DONE
	PSH#	PROJECTILES
	PSH	SHIP_R1
	JSR	SHOOT
	ADS#	2
MOVEMENT:	INB 	KBD_DATA
	CMA#	$4B
	JNE 	CHECK_RIGHT
	PSH# 	LEFT
	JMP  	MOVE
CHECK_RIGHT:	CMA# 	$4D
	JNE 	KBD_DONE
	PSH# 	RIGHT
MOVE:	PSH#	SHIP_R1
	PSH#	SHIP_R2
	JSR 	MOVE_SHIP
	ADS# 	3
KBD_DONE:	LDA#	INTERRUPT_ENA	; Re-enable KBD interrupts
	OUTB	KBD_CNTL
	POPA
	IRTN

; For timer and moving everything, we have to plan how things move
; and how to decide what direction something moves in
	; Need to decide on a timer count and have objects
	; move every time count finishes (causing interrupt)
	; Timer altered from pong code
; TIMER stores the number of timer cycles
; After each timer cycle, check if the timer has reached the minimum action delay
; Make minimum action delay how long each cycle takes? (probably
; If not, return
; If so, check against each action and trigger when met number of cycles
; Reset TIMER when it has triggered ENEMY_DELAY (the longest action delay)
TIMER_ISR: 	PSHA
	PSHX
	PSH#	PROJECTILES
	JSR 	MOVE_PROJ	; Move projectile(s)
	ADS# 	1
;	LDX# 	0
;BOMB_ACTION:	INC+  TIMERS
;          	LDA+	TIMERS
;	CMA#	BOMB_DELAY
;	JLT	ENEMY_ACTION
;	CLR+	TIMERS
;	JSR	MOVE_BOMBS
;	ADX#	1
;ENEMY_ACTION:	INC+	TIMERS
;	LDA+	TIMERS
;	CMA	ENEMY_DELAY
;	JLT	HIT_CHECKS
;	CLR+	TIMERS
;	JSR	MOVE_ENEMIES
;	ADX#	1
;HIT_CHECKS:	JSR	CHECK_HITS	; Hit logic
TIMER_DONE:	LDA#	ENABLE_AND_RESET
          	OUTB	TIM_CNTL
	POPX
          	POPA
          	IRTN		; END OF TIMER_ISR
	; Timers in order of bombs, enemy ships
TIMERS:	.BLKW	4, 0
DELAY:	.WORD 1000	; Game base speed
ENEMY_DELAY:	.WORD	$10	; # of iters before enemy ships move


	; Interrupt Vector
	.EQU @, $FF8
	.WORD KBD_ISR
	.EQU @, $FFB
	.WORD	TIMER_ISR
