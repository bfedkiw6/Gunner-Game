	.EQU 	KBD_CNTL, $000
	.EQU 	KBD_STAT, $000
	.EQU 	KBD_DATA, $001
	.EQU 	KBD_FLUSH, $40
	.EQU 	TIM_CNTL, $030
	.EQU 	TIM_STAT, $030
	.EQU 	TIM_VALUE, $031
	.EQU 	TIM_COUNT, $034

	.EQU 	SCORE, $106	; $106-$1?? depending on how many digits
	.EQU 	LEVEL, $124	; $124-$125 supporting up to 99
	.EQU 	GROUND, $2EE	; Start of last row (where ground is)
	.EQU  CRT_VBUF, $100
	.EQU 	CRT_END, $313
	.EQU 	CRT_CNTL, $316
	.EQU 	CRT_ROWS, $0E	; Number of rows in CRT
	.EQU 	CRT_COLS, $26	; Number of columns per row
          	.EQU 	CLEAR_DISPLAY, $01
	.EQU 	BELL, $06

	.EQU 	INTERRUPT_ENA, $80
	.EQU 	RESET_READY_BIT, $40
	.EQU 	START_AFTER_LOAD, $10
	.EQU 	ENABLE_RESET_AND_START, $D0
	.EQU 	ENABLE_AND_RESET, $C0

	; Game Related .EQUs
	.EQU	GROUND_CHAR, $2D	; ASCII for "-"
	.EQU	PROJ_CHAR, $A6
	.EQU	EXPLOSION1, $2A
	.EQU	EXPLOSION2, $B0
	; We may need multiple delays to have things move at different speeds
	; May need to test different delays to see how long in real time it takes
	; Delay at start of each level (maybe 2-5 seconds long, constant)
	; Delay for projectiles (constant)
	; Delay for bombs (constant)
	; Delay for enemy aircraft that changes based on time so need a word
	.EQU 	STARTLVL_DELAY, 8	; # of timer iters displaying level
	.EQU	BEATLVL_DELAY, 10	; # of timer iters displaying cleared msg
	.EQU	PROJ_DELAY, 1 	; # of timer iters before projectiles move
	.EQU 	BOMB_DELAY, 5	; # of timer iters before dropped bombs move
	.EQU 	SPAWN_DELAY, $10	; # of iters before enemy ships spawn
	.EQU	SPD1_DELAY, $30	; # of iters before ships move w/ different speeds
	.EQU	SPD2_DELAY, $20
	.EQU	SPD3_DELAY, $10

SETUP:	LDS# 	$E00
	; Keyboard setup
	LDA#	INTERRUPT_ENA
	OUTB	KBD_CNTL
	; Timer setup
	LDA	DELAY
	OUTW  TIM_VALUE		
	LDA#	ENABLE_RESET_AND_START
	OUTB 	TIM_CNTL  
	SIE
	; Load initial stage
	; Probably just the ground, ship, score, level
	; Let the user have maybe 5 seconds before ships start spawning in
MAIN:	JSR	START_GAME
	ADS#	1
	
LOOP:	NOP
	JMP	LOOP
	HLT
; Stores the ports for ^ and the left | of the ship/AA gun
SHIP_R1:	.WORD $100 + (11 * CRT_COLS) + (CRT_COLS/2) - 1
SHIP_R2:	.WORD $100 + (12*CRT_COLS) + (CRT_COLS/2) - 2
PROJECTILES:	.BLKW	10, 0
SHIP_HEALTH:	.WORD 5
CURR_LEVEL:	.WORD	$30
NUM_ENEMIES:	.WORD	0
SPEEDR1:	.BLKW	12, 0
SPEEDR2:	.BLKW	12, 0
SPEEDR3:	.BLKW	12, 0
SPEEDL1:	.BLKW	12, 0
SPEEDL2:	.BLKW	12, 0
SPEEDL3:	.BLKW	12, 0

	; Subroutines
	.EQU	@, $100

	; Initializes graphics and starts game
START_GAME:	BGN#  0
	PSHA
	PSHX 
	; Print Score
	LDX#	0
PRINT_SCORE:	LDC	SCORE_STR
	OUTB+	CRT_VBUF
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_SCORE
	LDA# '0'
SCORE_PT2:	OUTB+ CRT_VBUF
	AOC# 16
	JLT SCORE_PT2
	; Print level
	LDX#  0	
PRINT_LEVEL:	LDC	LEVEL_STR
	; To not overwrite Score, shift over XR (leave room for the level #)
	ADX#	30
	OUTB+	CRT_VBUF
	; Return back to original XR so next character can be gotten
	SBX#	30
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_LEVEL
PRINT_PT2:	LDA# '0'
	OUTB	LEVEL
	LDA# '1'
	OUTB	LEVEL + 1
	; Build the Turret
	JSR 	DISPLAY_SHIP		
	; Print the ground
	LDA#  GROUND_CHAR	; Load up ground character
	LDX#  GROUND	; Set ground to start on last row
PRINT_GROUND:	OUTB+	0	; Output across whole row
	AOC# 	CRT_END
	JLE   PRINT_GROUND
	POPA
	POPX
	FIN#  0
	RTN          
SCORE_STR:	.WORD	'Sco'
SCORE_STR2:	.WORD	're:'
LEVEL_STR:	.WORD	'Lev'	; Can shorten to lvl if need space for score
LEVEL_STR2:	.WORD	'el:'

	; Display on Screen the start of level
START_LVL:	BGN# 	0
	PSHA
	PSHX
PRINT_SLVL:	LDC	LVL_S_STR
	ADX#	$CD
	OUTB+	CRT_VBUF
	SBX#	$CD
	AOC#	6	
	JNE	PRINT_SLVL	
	ADX#	$CD
	LDA	CURR_LEVEL
	OUTB+	CRT_VBUF
	POPX
	POPA
	FIN# 	0
	RTN
LVL_S_STR:	.WORD	'Lev'	
LVL_S_STR2:	.WORD	'el '

	; Display on Screen the beating level
BEAT_LVL:	BGN# 	0
	PSHA
	PSHX
PRINT_BLVL:	LDC	LVL_B_STR
	ADX#	$C9
	OUTB+	CRT_VBUF
	SBX#	$C9
	AOC#	15	
	JNE	PRINT_BLVL	
	POPX
	POPA
	FIN# 	0
	RTN
LVL_B_STR:	.WORD	'Lev'	
LVL_B_STR2:	.WORD	'el '
LVL_B_STR3:	.WORD	'Com'
LVL_B_STR4:	.WORD	'ple'
LVL_B_STR5:	.WORD	'te!'

	; Clear start/beat level from screen
	.EQU	SIZE_WORDS, 2
CLR_DISPLAY:	BGN# 	0
	PSHA
	PSHX
CLR_DISP:	LDA#	' '
	ADX#	$CD
	OUTB+	CRT_VBUF
	SBX#	$CD
	AOC	!SIZE_WORDS	
	JNE	CLR_DISP	
	POPX
	POPA
	FIN# 	0
	RTN
	
	; Shoot subroutine shoots if no projectile in row above ship
	.EQU	S_PROJ, 3
	.EQU	S_SHIP_R1, 2
SHOOT:	BGN# 	0
	PSHA
	PSHX
	LDX#	9
CHECK_PROJ:	LDA&	!S_PROJ
	CMA#	0	; See if there is space for projectile
	JEQ	ADD_PROJ	; If space not filled, add projectile
	; Check if port is in row above ship
CHECK_ABOVE:	CMA#	$100 + (10 * CRT_COLS)
	JGE	DONE	; No space for new projectile	
SUB_JUMP:	SOJ	CHECK_PROJ	; Port is in row above ship, check next element
	; Open space above ship	
ADD_PROJ:	LDA	!S_SHIP_R1
	SBA#	38
	STA&	!S_PROJ
	; Small hack to get the projectile to display right above the ship
	; since move moves before displaying
	STA	S_PORT
	LDA#	PROJ_CHAR
	OUTB*	S_PORT
DONE:	POPX
	POPA
	FIN# 	0
	RTN
S_PORT:	.WORD	0

	; Get new position for each projectile
	.EQU	M_PROJ, 2
	;.EQU	MP_ENEMIES, 2
MOVE_PROJ:	BGN# 	0
	PSHA
	PSHX
	PSH	!M_PROJ	
	JSR	CLEAR_PROJ	; Clear current projectiles
	ADS#	1
	LDX#	0
MOVING:	LDA&	!M_PROJ	; Shift projectiles up a row
	SBA#	38
	STA	PROJ_PORT
	CMA#	$126	; See if it is out playing field
	JLT	RESET
	; Check if projectile hits an enemy ship
	;INB*	PROJ_PORT
	;CMA#	'|'
	;JEQ	CLEAR_PE	; There is a hit
	;CMA#	'o'
	;JEQ	CLEAR_PE	; There is a hit
	;JMP	CHECK_INDEX	; No hit, continue moving projectiles
;CLEAR_PE:	CLR&	!M_PROJ	
	;PSH	!MP_ENEMIES
	;PSH	PROJ_PORT
	;PSH#	7
	;JSR	CLEAR_ARRAY
	;ADS#	3
	;JMP	CHECK_INDEX
	; Not out of screen & did not hit enemy ship, save new location	
	STA&	!M_PROJ	
	JMP	CHECK_INDEX	
RESET:	CLR&	!M_PROJ	; If proj goes out of screen, clear in array
CHECK_INDEX:	AOC#	10
	JLT	MOVING
	PSH	!M_PROJ
	JSR	DISPLAY_PROJ	; Redisplay projectiles at new ports
	ADS#	1
	POPX	
	POPA
	FIN#	0 	
	RTN
PROJ_PORT:	.WORD	0

	; Display projectiles
	.EQU	D_PROJ, 2
DISPLAY_PROJ:	BGN#	0
	PSHA	
	PSHX
	LDX#	0
DP_LOOP:	LDA&	!D_PROJ
	STA	D_CURR_PORT
	LDA#  PROJ_CHAR
	OUTB*	D_CURR_PORT
	AOC#	10
	JLT	DP_LOOP
	POPX
	POPA
	FIN# 	0
	RTN
D_CURR_PORT:	.WORD	0

	; Clear projectiles from screen, not array
	.EQU	C_PROJ, 2
CLEAR_PROJ:	BGN#	0
	PSHA
	PSHX
	LDX#	0
CP_LOOP:	LDA&	!C_PROJ	
	STA	C_CURR_PORT
	LDA#	' '
	OUTB*	C_CURR_PORT
	AOC#	10
	JLT	CP_LOOP
	POPX
	POPA
	FIN# 	0
	RTN
C_CURR_PORT:	.WORD	0

	; Clear a value from an array given a value
	.EQU	ARRAY, 4
	.EQU	PORT, 3
	.EQU	SIZE, 2
CLEAR_ARRAY:	BGN#	0
	PSHA
	PSHX
	LDX#	0
ARRAY_LOOP:	LDA&	!ARRAY	; Look for where port exists in array
	CMA	!PORT
	JNE	ARRAY_CHECK
	LDA#	0	; Port exists in array, clear it
	STA&	!ARRAY
ARRAY_CHECK:	AOC	!SIZE
	JLT	ARRAY_LOOP
	POPX
	POPA
	FIN# 	0
	RTN

	; Move enemy ships
	.EQU	M_ENEMIES, 4
	.EQU	MP_PROJ, 3
	.EQU	DIRECTION, 2
MOVE_ENEMY:	BGN# 	0
	PSHA
	PSHX
	LDX#	0	; Reset Index
CLR_ENEMIES:	PSH	!M_ENEMIES	
	JSR	CLEAR_ENEMY	; Clear current ships
	ADS#	1
	AOC#	12
	JNE	CLR_ENEMIES
	LDA	!DIRECTION
	CMA#	1	
	LDX#	0
	JEQ	MOVE_RIGHT	; If direction = 1, move ships right
MOVE_LEFT:	LDA&	!M_ENEMIES	; Shift ships to the left
	CMA#	0	; See if it is a valid port
	JEQ	CHECK_INDX1	
	SBA#	1
	STA	CURR_PORT
	; See if it is out of screen on left
	SBA#	$100	
	MOD#	38
	CMA#	0	
	JEQ	RESET1
	; See if it is hit by a projectile	
	INB*	CURR_PORT
	CMA#	PROJ_CHAR
	JNE	SET_ENEMY1
	CLR&	!M_ENEMIES	
	PSH	!MP_PROJ
	PSH	CURR_PORT
	PSH#	10
	JSR	CLEAR_ARRAY
	ADS#	3
	JMP	CHECK_INDX1
	; Not out of screen, save new location
SET_ENEMY1:	LDA	CURR_PORT		
	STA&	!M_ENEMIES	
	JMP	CHECK_INDX1	
RESET1:	CLR&	!M_ENEMIES	; If proj goes out of screen, clear in array
CHECK_INDX1:	AOC#	12
	JLT	MOVE_LEFT
	JMP	NEW_DISPLAY			
MOVE_RIGHT:	LDA&	!M_ENEMIES	; Shift ships to the right
	CMA#	0	; See if it is a valid port
	JEQ	CHECK_INDX2
	ADA#	1
	STA	CURR_PORT
	; See if it is out of screen on right
	SBA#	$125	
	MOD#	38
	CMA#	0	
	JEQ	RESET2		
	; See if it is hit by a projectile	
	INB*	CURR_PORT
	CMA#	PROJ_CHAR
	JNE	SET_ENEMY1
	CLR&	!M_ENEMIES	
	PSH	!MP_PROJ
	PSH	CURR_PORT
	PSH#	10
	JSR	CLEAR_ARRAY
	ADS#	3
	JMP	CHECK_INDX2
	; Not out of screen, save new location
SET_ENEMY2:	LDA	CURR_PORT		
	STA&	!M_ENEMIES	
	JMP	CHECK_INDX2	
RESET2:	CLR&	!M_ENEMIES	; If proj goes out of screen, clear in array
CHECK_INDX2:	AOC#	12
	JLT	MOVE_RIGHT
NEW_DISPLAY:	LDX#	0
DISPLAY_ALL:	LDA&	!M_ENEMIES
	STA	M_ENMY_PORT
	PSH	M_ENMY_PORT
	PSH	!DIRECTION
	JSR	DISPLAY_ENEMY	; Redisplay ships at new ports
	ADS#	2
	POPX	
	POPA
	FIN#	0 	
	RTN
M_ENMY_PORT:	.WORD	0
CURR_PORT:	.WORD	0

	; Display enemy ship
	.EQU	D_ENMY_PORT, 3
	.EQU	D_DIRECTION, 2
DISPLAY_ENEMY:	BGN#	0
	PSHA	
	PSHX
	LDA	!D_ENMY_PORT
	STA	TEMP_PORT_R
	STA	TEMP_PORT_L
	LDA	!D_DIRECTION
	CMA#	1
	JEQ	MOVE_R
	; Looking at right of screen
	LDA	TEMP_PORT_L	
	SBA#	$125	; See if left of ship is at rightmost spot on screen
	MOD#	38
	CMA#	0	
	JEQ	PRINT_L
	LDA	TEMP_PORT_L
	ADA#	1	
	SBA#	$125	; See if left of ship is 1 left of rightmost spot on screen
	MOD#	38
	CMA#	0	
	JEQ	PRINT_MID_L
	; Looking at left of screen
MOVE_R:	LDA	TEMP_PORT_R
	ADA#	2	
	SBA#	$100	; See if right of ship is at leftmost spot on sceen
	MOD#	38
	CMA#	0	
	JEQ	PRINT_R
	LDA	TEMP_PORT_R
	ADA#	1	
	SBA#	$100	; See if right of ship is 1 right of leftmost spot on screen
	MOD#	38
	CMA#	0
	JEQ	PRINT_MID_R
	; Print all characters, nothing offscreen
	LDX# 	1
	LDA#	'o'
	OUTB& !D_ENMY_PORT
	LDA#	'|'	
	OUTB*	!D_ENMY_PORT
	ADX#	1		
	OUTB&	!D_ENMY_PORT
	JMP	STOP_PRINT
PRINT_R:	LDX#	2
	LDA#	'|'			
	OUTB&	!D_ENMY_PORT
	JMP	STOP_PRINT
PRINT_L:	LDX# 	1
	LDA#	'|'	
	OUTB*	!D_ENMY_PORT
	JMP	STOP_PRINT
PRINT_MID_R:	LDX# 	1
	LDA#	'o'
	OUTB& !D_ENMY_PORT
	LDA#	'|'	
	ADX#	1		
	OUTB&	!D_ENMY_PORT
	JMP	STOP_PRINT
PRINT_MID_L:	LDX# 	1
	LDA#	'o'
	OUTB& !D_ENMY_PORT
	LDA#	'|'	
	OUTB*	!D_ENMY_PORT
	JMP	STOP_PRINT
STOP_PRINT:	POPX
	POPA
	FIN# 	0
	RTN
TEMP_PORT_L:	.WORD	0
TEMP_PORT_R:	.WORD	0

	; Clear enemy ship from screen 
	.EQU	C_ENEMIES, 2
CLEAR_ENEMY:	BGN#	0
	PSHA
	PSHX
	STX	C_INDEX
	LDA&	!C_ENEMIES
	STA	C_ENMY_PORT
	LDX#	0
	LDA# 	' '	; Clear previous enemy ship position
CLEAR_ALL:	OUTB&	C_ENMY_PORT
	AOC#	3
	JLT	CLEAR_ALL
	POPX
	POPA
	FIN# 	0
	RTN
C_ENMY_PORT:	.WORD	0
C_INDEX:	.WORD	0

	; Spawns an enemy ship
	.EQU SPEED, 2
SPAWN:	BGN#	0
	PSHA
	PSHX
	LDA	!SPEED
	CMA#	0
	JNE	ONE
	LDA#	SPEEDR1
	JMP	GET_ROW
ONE:	CMA#	1
	JNE	TWO
	LDA#	SPEEDR2
	JMP	GET_ROW
TWO:	CMA#	2
	JNE	THREE
	LDA#	SPEEDR3
	JMP	GET_ROW
THREE:	CMA# 	3
	JNE	FOUR
	LDA#	SPEEDL1
	JMP	GET_ROW
FOUR:	CMA#	4
	JNE 	FIVE
	LDA#	SPEEDL2
	JMP	GET_ROW
FIVE:	LDA#	SPEEDL3
GET_ROW:	STA	S_SPEED_ARR
	PSH#	5	; Get number between 1-6 inclusive
	JSR	RANDOM
	ADS#	1
	ADA#	1
	MUL# 	38
	STA	S_ROW
	LDA	!SPEED	; Check direction
	CMA#	3
	JLT	S_LESS
	LDA#	$125	; Port = $125 + ACC * 38 if from right
	JMP 	S_CONT
S_LESS:	LDA#	$FE	; Port = $100 + ACC * 38 if from left
S_CONT:	ADA	S_ROW
	STA	S_ROW
	LDX#	0
S_PUSH:	LDA&	S_SPEED_ARR
	CMA#	0
	JEQ	S_EMPTY
	AOC#	12
	JLT	S_PUSH
S_EMPTY:	TXA
	ADA	S_SPEED_ARR
	STA	S_SPEED_ARR
	LDA	S_ROW
	STA*	S_SPEED_ARR
	POPX
	POPA
	FIN#	0
	RTN
S_SPEED_ARR:	.WORD	0
S_ROW:	.WORD	0

	; Displays ship at ports
	; Uses global ship variables
DISPLAY_SHIP:	BGN#	0
	PSHA
	PSHX
	LDA#  '^'
	OUTB*	SHIP_R1
	LDX# 	1
	LDA#	'-'
	OUTB& SHIP_R2
	LDA#	'|'	
	OUTB*	SHIP_R2
	ADX#	1		
	OUTB&	SHIP_R2
	POPX
	POPA
	FIN# 	0
	RTN

	; Clears ship
	.EQU	C_ROW1, 3
	.EQU 	C_ROW2, 2
CLEAR_SHIP:	BGN#	0
	PSHA
	PSHX
	LDX#	0
	LDA# 	' '	; Clear previous ship positions
	OUTB*	!C_ROW1
CLEAR_R2:	OUTB&	!C_ROW2
	AOC#	3
	JLT	CLEAR_R2
	POPX
	POPA
	FIN#	0
	RTN

	; Moves the ship left(1) or right(2)
	.EQU	LorR, 4
	.EQU	M_ROW1, 3
	.EQU	M_ROW2, 2
	.EQU	LEFTMOST_POS, $2C8
	.EQU	RIGHTMOST_POS, $2ED
MOVE_SHIP:	BGN# 	0
	PSHA
	PSHX
	PSH*	!M_ROW1	; Preemptively push current addresses for clear
	PSH*	!M_ROW2
	LDA	!LorR
	CMA#	1
	JNE	M_RIGHT
	LDA*	!M_ROW2
	CMA#	LEFTMOST_POS	; Check if already at leftmost position
	JEQ	MOVE_DONE
	DEC*	!M_ROW1	; Set new ship ports
	DEC*	!M_ROW2
	JMP	M_MOVE
M_RIGHT:	LDA*	!M_ROW2
	ADA#	2
	CMA#	RIGHTMOST_POS	; Check if already at rightmost position
	JEQ	MOVE_DONE
	INC*	!M_ROW1	; Set new ship ports
	INC*	!M_ROW2
M_MOVE:	JSR	CLEAR_SHIP	; Clear ship
	JSR 	DISPLAY_SHIP	; Display ship at new ports
MOVE_DONE:	ADS#	2	; Remove parameters for clear from stack
	POPX
	POPA
	FIN#	0
	RTN

	; Random function from pong
	.EQU	RANDOM_MAX, 2
RANDOM:	BGN#	0
	LDA 	SEED
	MUL#	2779
	ADA#	1997
	MOD#	2048
	STA	SEED
	INC	!RANDOM_MAX
	MOD	!RANDOM_MAX
	FIN#	0
	RTN
SEED:	.WORD 0

	; ISRs
	.EQU	@, $500

	; Keyboard ISR for player controls
	.EQU	LEFT, 1
	.EQU 	RIGHT, 2
KBD_ISR:	PSHA
	LDA#	0	; Finish this interrupt before allowing more
	OUTB	KBD_CNTL
	INB	KBD_DATA
	CMA#	$1B
	JEQ 	MOVEMENT	; Control sequence must be a ship move
	CMA# 	$20
	JNE 	KBD_DONE
	PSH#	PROJECTILES
	PSH	SHIP_R1
	JSR	SHOOT
	ADS#	2
MOVEMENT:	INB 	KBD_DATA
	CMA#	$4B
	JNE 	CHECK_RIGHT
	PSH# 	LEFT
	JMP  	MOVE
CHECK_RIGHT:	CMA# 	$4D
	JNE 	KBD_DONE
	PSH# 	RIGHT
MOVE:	PSH#	SHIP_R1
	PSH#	SHIP_R2
	JSR 	MOVE_SHIP
	ADS# 	3
KBD_DONE:	LDA#	INTERRUPT_ENA	; Re-enable KBD interrupts
	OUTB	KBD_CNTL
	POPA
	IRTN

; For timer and moving everything, we have to plan how things move
; and how to decide what direction something moves in
	; Need to decide on a timer count and have objects
	; move every time count finishes (causing interrupt)
	; Timer altered from pong code
; TIMER stores the number of timer cycles
; After each timer cycle, check if the timer has reached the minimum action delay
; Make minimum action delay how long each cycle takes? (probably
; If not, return
; If so, check against each action and trigger when met number of cycles
TIMER_ISR: 	PSHA
	PSHX
	PSH#	PROJECTILES
	;PSH#	SPEEDL1
	JSR 	MOVE_PROJ	; Move projectile(s)
	ADS# 	1

	LDX# 	0

; TRYING TO ADD START AND BEAT LEVEL DISPLAY
	;INC	CURR_LEVEL
;DISPLAY_START:	INC+	TIMERS
	;LDA+	TIMERS
	;JSR	START_LVL
	;CMA#	STARTLVL_DELAY
	;JNE	DISPLAY_START
	;PSH#	7
	;JSR	CLR_DISPLAY
	;ADS# 1
	;CLR+	TIMERS

	;ADX#	1
	INC+	TIMERS
	LDA+	TIMERS
	CMA	SPAWN_DELAY
	;JLT	BOMB_ACTION
	JLT	T_SPEED1
	LDA	NUM_ENEMIES
	CMA#	12	; See if there is room for new enemies
	;JEQ	BOMB_ACTION
	JEQ	T_SPEED1
	CLR+	TIMERS
	PSH#	5	; Get speed
	JSR	RANDOM
	ADS#	1
	PSHA
	JSR	SPAWN
	ADS#	1
	INC	NUM_ENEMIES
;BOMB_ACTION:	ADX#	1
;	INC+  TIMERS
;          	LDA+	TIMERS
;	CMA#	BOMB_DELAY
;	JLT	ENEMY_ACTION
;	CLR+	TIMERS
;	JSR	MOVE_BOMBS
T_SPEED1:	ADX#	1
	INC+	TIMERS
	LDA+	TIMERS
	CMA	SPD1_DELAY
	JLT	T_SPEED2
	CLR+	TIMERS
	PSH#	SPEEDL1
	PSH#	PROJECTILES
	PSH#	0
	JSR	MOVE_ENEMY
	ADS#	3
	PSH#	SPEEDR1
	PSH#	PROJECTILES
	PSH#	1
	JSR	MOVE_ENEMY
	ADS#	3
T_SPEED2:	ADX#	1
	INC+	TIMERS
	LDA+	TIMERS
	CMA	SPD2_DELAY
	JLT	T_SPEED3
	CLR+	TIMERS
	PSH#	SPEEDL2
	PSH#	PROJECTILES
	PSH#	0
	JSR	MOVE_ENEMY
	ADS#	3
	PSH#	SPEEDR2
	PSH#	PROJECTILES
	PSH#	1
	JSR	MOVE_ENEMY
	ADS#	3
T_SPEED3:	ADX#	1
	INC+	TIMERS
	LDA+	TIMERS
	CMA	SPD3_DELAY
	JLT	TIMER_DONE
	CLR+	TIMERS
	PSH#	SPEEDL3
	PSH#	PROJECTILES
	PSH#	0
	JSR	MOVE_ENEMY
	ADS#	3
	PSH#	SPEEDR3
	PSH#	PROJECTILES
	PSH#	1
	JSR	MOVE_ENEMY
	ADS#	3
;	JLT	HIT_CHECKS
;	ADX#	1
;HIT_CHECKS:	JSR	CHECK_HITS	; Hit logic
TIMER_DONE:	LDA#	ENABLE_AND_RESET
          	OUTB	TIM_CNTL
	POPX
          	POPA
          	IRTN		; END OF TIMER_ISR
	; Timers in order of spawn, bombs, enemy ships
TIMERS:	.BLKW	4, 0
DELAY:	.WORD 1000	; Game base speed

	; Interrupt Vector
	.EQU @, $FF8
	.WORD KBD_ISR
	.EQU @, $FFB
	.WORD	TIMER_ISR
