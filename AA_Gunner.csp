	.EQU 	KBD_CNTL, $000
	.EQU 	KBD_STAT, $000
	.EQU 	KBD_DATA, $001
	.EQU 	KBD_FLUSH, $40
	.EQU 	TIM_CNTL, $030
	.EQU 	TIM_STAT, $030
	.EQU 	TIM_VALUE, $031
	.EQU 	TIM_COUNT, $034

	.EQU 	SCORE, $106	; $106-$1?? depending on how many digits
	.EQU 	LEVEL, $124	; $124-$125 supporting up to 99
	.EQU 	GROUND, $2EE	; Start of last row (where ground is)
	.EQU  CRT_VBUF, $100
	.EQU 	CRT_END, $313
	.EQU 	CRT_CNTL, $316
	.EQU 	CRT_ROWS, $0E	; Number of rows in CRT
	.EQU 	CRT_COLS, $26	; Number of columns per row
          	.EQU 	CLEAR_DISPLAY, $01
	.EQU 	BELL, $06

	.EQU 	INTERRUPT_ENA, $80
	.EQU 	RESET_READY_BIT, $40
	.EQU 	START_AFTER_LOAD, $10
	.EQU 	ENABLE_RESET_AND_START, $D0
	.EQU 	ENABLE_AND_RESET, $C0


	; Game Related .EQUs
	.EQU	GROUND_CHAR, $2D	; ASCII for "-"

SETUP:	LDS# 	$E00
	; Keyboard setup
	LDA#	INTERRUPT_ENA
	OUTB	KBD_CNTL
	; Timer setup
	SIE
	; Load initial stage
	; Probably just the ground, ship, score, level
	; Let the user have maybe 5 seconds before ships start spawning in
MAIN:	JSR START_GAME
LOOP:	NOP
	JMP	LOOP
	HLT

; Stores the ports for ^ and the left | of the ship/AA gun
SHIP_R1:	.WORD $100 + (11 * CRT_COLS) + (CRT_COLS/2) - 1
SHIP_R2:	.WORD $100 + (12*CRT_COLS) + (CRT_COLS/2) - 2

	; Subroutines
	.EQU	@, $200
; void display()

; void startGame()
	; Loads graphics
	; Need to go through first row and load score and level
	; Score: ######	Lvl: ##
	; Ground can be ------ or _____ see what looks better

START_GAME:	BGN#  0
	PSHA
	PSHX 
	; Print Score
	LDX#	0
PRINT_SCORE:	LDC	SCORE_STR
	OUTB+	CRT_VBUF
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_SCORE
	LDA# '0'
SCORE_PT2:	OUTB+ CRT_VBUF
	AOC# 16
	JLT SCORE_PT2
	; Print level
	LDX#  0	
PRINT_LEVEL:	LDC	LEVEL_STR
	; To not overwrite Score, shift over XR (leave room for the level #)
	ADX#	30
	OUTB+	CRT_VBUF
	; Return back to original XR so next character can be gotten
	SBX#	30
	AOC#	6	; Check if all characters are printed
	JNE	PRINT_LEVEL
PRINT_PT2:	LDA# '0'
	OUTB	LEVEL
	LDA# '1'
	OUTB	LEVEL + 1
	; Build the Turret
	LDA#  '^'	; Print turret at middle of screen
	OUTB*	SHIP_R1
	LDX# 	1
	LDA#	'-'
	OUTB& SHIP_R2
	LDA#	'|'	
	OUTB*	SHIP_R2
	ADX#	1		
	OUTB&	SHIP_R2		
	; Print the ground
	LDA#  GROUND_CHAR	; Load up ground character
	LDX#  GROUND	; Set ground to start on last row
PRINT_GROUND:	OUTB+	0	; Output across whole row
	AOC# 	CRT_END
	JLE   PRINT_GROUND
	POPA
	POPX
	FIN#  0
	RTN          
SCORE_STR:	.WORD	'Sco'
SCORE_STR2:	.WORD	're:'
LEVEL_STR:	.WORD	'Lev'	; Can shorten to lvl if need space for score
LEVEL_STR2:	.WORD	'el:'

	; Work in progress
	; Need to figure out how to initialize and move projectiles
SHOOT:	BGN# 	0
	PSHA
	POPA
	FIN# 	0
	RTN

	; Moves the ship left(1) or right(2)
	.EQU	LorR, 4
	.EQU	ROW1, 3
	.EQU	ROW2, 2
	.EQU	LEFTMOST_POS, $2C8
	.EQU	RIGHTMOST_POS, $2ED
MOVE_SHIP:	BGN# 	0
	PSHA
	PSHX
	LDA	!LorR
	CMA#	1
	JNE	M_RIGHT
	LDX#	0
	LDA*	!ROW2
	CMA#	LEFTMOST_POS	; Check if already at leftmost position
	JEQ	MOVE_DONE
	SBA# 	1
	STA	NEW_ROW2	; Store new leftmost position
SHIFT_LEFT:	INB&	SHIP_R2	; Move ship at row 2 one to the left
	OUTB&	NEW_ROW2
	AOC#	3
	JLT	SHIFT_LEFT
	LDA*	!ROW1	; Move ship at row 1 one to the left
	SBA#	1
	STA	NEW_ROW1
	INB*	SHIP_R1
	OUTB*	NEW_ROW1
	LDA#	' '	; Clear old positions
	OUTB* SHIP_R1
	OUTB&	NEW_ROW2
	DEC*	!ROW1	; Set new ship ports
	DEC*	!ROW2
	JMP	MOVE_DONE
M_RIGHT:	LDX#	2
	LDA*	!ROW2
	ADA#	2
	CMA#	RIGHTMOST_POS	; Check if already at rightmost position
	JEQ	MOVE_DONE
	ADA# 	1
	STA	NEW_ROW2	; Store new rightmost position
SHIFT_RIGHT:	INB&	SHIP_R2	; Move ship at row 2 one to the right
	ADX#	1
	OUTB&	SHIP_R2
	SBX#	1
	SOJ	SHIFT_RIGHT
	LDA*	!ROW1	; Move ship at row 1 one to the right
	ADA#	1
	STA	NEW_ROW1
	INB*	SHIP_R1
	OUTB*	NEW_ROW1
	LDA#	' '
	OUTB* SHIP_R1
	OUTB*	SHIP_R2
	INC*	!ROW1	; Set new ship ports
	INC*	!ROW2
MOVE_DONE:	LDA#	0	; Reset variables
	STA	NEW_ROW1
	STA	NEW_ROW2
	POPX
	POPA
	FIN#	0
	RTN
NEW_ROW1:	.WORD 0
NEW_ROW2:	.WORD 0
; void moveTurret(char key, int x)

; void play()

; For timer and moving everything, we have to plan how things move
; and how to decide what direction something moves in

	; ISRs
	.EQU	@, $300
	; Keyboard ISR for player controls
	.EQU	LEFT, 1
	.EQU 	RIGHT, 2
KBD_ISR:	PSHA
	LDA#	0	; Finish this interrupt before allowing more
	OUTB	KBD_CNTL
	INB	KBD_DATA
	CMA#	$1B
	JEQ 	MOVEMENT
	CMA# 	$20
	JNE 	KBD_DONE
	JSR	SHOOT
MOVEMENT:	INB 	KBD_DATA
	CMA#	$4B
	JNE 	CHECK_RIGHT
	PSH# 	LEFT
	JMP  	MOVE
CHECK_RIGHT:	CMA# 	$4D
	JNE 	KBD_DONE
	PSH# 	RIGHT
MOVE:	PSH#	SHIP_R1
	PSH#	SHIP_R2
	JSR 	MOVE_SHIP
	ADS# 	3
KBD_DONE:	LDA#	INTERRUPT_ENA	; Re-enable KBD interrupts
	OUTB	KBD_CNTL
	POPA
	IRTN

	.EQU @, $FF8
	.WORD KBD_ISR

; /\
;|--|

; ^
;|-|